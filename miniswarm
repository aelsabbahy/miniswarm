#!/bin/bash

set -eu

info() {
  echo "INFO: $*"
}

err() {
  echo "ERROR: $*"
}

line_prefix() {
  sed -e "s/^/[$1] /"
}

create_instance() {
  docker-machine create -d virtualbox "$1" 2>&1 | line_prefix "$1"
}

wait_for_command() {
    local command="$1"
    local retry=${2:-60}
    local sleep_time=${3:-1}

    local tries=0
    while (( tries < retry ));do
        tries=$((tries+1))
        if eval "$command";then
            echo
            return 0
        fi
        echo -n '.'
        sleep "$sleep_time"
    done
    ((tries > 1)) && echo "TIMED OUT"
    return 1
}

generate_names() {
  local name=$1
  local count=$2
  for ((i=0; i<count; i++)); do
    echo "${name}${i}"
  done
}

extra_instances() {
  local filter=$1
  shift
  local wanted_instances=( ${@+"$@"} )
  got_instances=$(docker-machine ls -q | grep "$filter" | sort)
  comm -13 <(IFS=$'\n'; echo "${wanted_instances[*]}" | sort) <(echo -e "$got_instances" | sort)
}

missing_instances() {
  local filter=$1
  shift
  local wanted_instances=( ${@+"$@"} )
  got_instances=$(docker-machine ls -q | grep "$filter" | sort)
  comm -23 <(IFS=$'\n'; echo "${wanted_instances[*]}" | sort) <(echo -e "$got_instances" | sort)
}

set_wanted_instances() {
  wanted_managers=( $(generate_names 'ms-manager' "$num_managers") )
  wanted_workers=( $(generate_names 'ms-worker' "$num_workers") )
  missing_managers=( $(missing_instances "ms-manager" "${wanted_managers[@]+"${wanted_managers[@]}"}") )
  missing_workers=( $(missing_instances "ms-worker" "${wanted_workers[@]+"${wanted_workers[@]}"}") )
  missing_instances=( "${missing_managers[@]+"${missing_managers[@]}"}" "${missing_workers[@]+"${missing_workers[@]}"}" )
  extra_managers=( $(extra_instances "ms-manager" "${wanted_managers[@]+"${wanted_managers[@]}"}") )
  extra_workers=( $(extra_instances "ms-worker" "${wanted_workers[@]+"${wanted_workers[@]}"}") )
  extra_instances=( "${extra_managers[@]+"${extra_managers[@]}"}" "${extra_workers[@]+"${extra_workers[@]}"}" )
  echo "extra" "${extra_managers[@]+"${extra_managers[@]}"}"
  echo "extra" "${extra_workers[@]+"${extra_workers[@]}"}"
  echo "missing" "${missing_workers[@]+"${missing_workers[@]}"}"
  echo "missing" "${missing_managers[@]+"${missing_managers[@]}"}"
  echo "missing_total" "${missing_instances[@]+"${missing_instances[@]}"}"
  echo "extra_total" "${extra_instances[@]+"${extra_instances[@]}"}"
  exit 1
}

create_instances() {
  for i in $missing_managers; do
    # If boot2docker.iso doesn't exist, then run fist command serially to get it
    if ! [[ -e ~/.docker/machine/cache/boot2docker.iso ]]; then
      create_instance "$i"
    else
      create_instance "$i" &
      # VirtualBox throws errors sometimes when too many machines are launched in parallel
      sleep 2
    fi
  done
  for i in $missing_workers; do
      create_instance "$i" &
      # VirtualBox throws errors sometimes when too many machines are launched in parallel
      sleep 2
  done
  wait
}

delete_instances() {
  to_delete="$extra_managers $extra_workers"
  if [[ $to_delete == " " ]]; then
    return 0
  fi
  # Gracefully leave cluster
  if [[ ${1:-""} != "--force" ]]; then
    for i in $to_delete; do
      delete_from_cluster "$i" &
    done
    wait
  fi
  docker-machine rm -y $to_delete
}

delete_from_cluster() {
  leave_cluster "$1"
  # In case there are multiple matches for a given name
  ids=$(docker-machine ssh ms-manager0 docker node ls -qf name="$1")
  for id in $ids; do
    # Wait for it to be in down state so we can remove
    info "Waiting for node id=$id to be in a down state"
    wait_for_command "docker-machine ssh ms-manager0 docker node ls -f id=$id |grep -q Down"
    docker-machine ssh ms-manager0 docker node rm $id > /dev/null
  done
}

stop_instances() {
  # Cluster gets out of wack when IP addresses change
  # remove workers
  for i in $(docker-machine ls -q | grep "ms-worker[0-9][0-9]*"); do
    info "Stopping instance: $i"
    {
      delete_from_cluster "$i" | line_prefix "$i";
      docker-machine stop "$i" | line_prefix "$i";
    } &
  done
  wait
  # Kill the masters
  for i in $(docker-machine ls -q | grep "ms-manager[0-9][0-9]*"); do
    [[ $i == "ms-manager0" ]] && continue
    info "Stopping instance: $i"
    {
      leave_cluster "$i" | line_prefix "$i";
      docker-machine stop "$i" | line_prefix "$i";
    } &
  done
  wait
  # Kill the last remaining master
  leave_cluster "ms-manager0" | line_prefix "ms-manager0";
  docker-machine stop "ms-manager0" | line_prefix "ms-manager0";
}

start_instance() {
  info "Starting instance: $1"
  docker-machine start "$1"
  docker-machine regenerate-certs -f "$1"
  info "Waiting for instance name=$1 to be in a running state"
  wait_for_command "docker-machine ls --filter name=$1 --filter state=running -q | grep -q $1"
}

start_instances() {
  to_start=$(docker-machine ls -q --filter state=Stopped | grep "ms-\(worker\|manager\)[0-9][0-9]*" || true)
  for i in $to_start; do
    start_instance "$i" | line_prefix "$i" &
    #docker-machine start "$i" > /dev/null &
    #docker-machine regenerate-certs -f "$i" > /dev/null &
  done
  wait
  #docker-machine start $(docker-machine ls -q | grep "ms-\(worker\|manager\)[0-9][0-9]*")
}

scale_cluster() {
  set_wanted_instances
  info "Creating: $missing_managers $missing_workers"
  info "Deleting: $extra_managers $extra_workers"
  create_instances
  delete_instances
  start_instances
  create_cluster
}

create_cluster() {
  lookup_and_set_manager_ip
  init_cluster
  lookup_and_set_tokens
  for i in $wanted_managers; do
      join_cluster "$i" "$manager_token" &
  done
  for i in $wanted_workers; do
      join_cluster "$i" "$worker_token" &
  done
  wait
}

node_in_cluster() {
  docker-machine ssh ms-manager0 docker node ls 2>/dev/null | grep -q "$1 *Ready"
}

join_cluster() {
  if ! node_in_cluster "$1"; then
    docker-machine ssh "$1" docker swarm leave --force 2> /dev/null | line_prefix "$1"
    docker-machine ssh "$1" docker swarm join "$manager_ip" --token "$2" 2>&1 | line_prefix "$1"
  fi
}

leave_cluster() {
  if node_in_cluster "$1"; then
    docker-machine ssh ms-manager0 docker node update --availability drain "$1" | line_prefix "$1"
    # Give it a few sec to drain
    sleep 3
    docker-machine ssh "$1" docker swarm leave --force 2>&1 | line_prefix "$1"
  fi
}

cluster_is_initialized() {
  docker-machine ssh ms-manager0 docker node ls > /dev/null 2>&1
  #docker-machine ssh ms-manager0 docker node ls
}

init_cluster() {
  if ! cluster_is_initialized; then
    docker-machine ssh ms-manager0 docker swarm leave --force 2> /dev/null | line_prefix "ms-manager0"
    docker-machine ssh ms-manager0 docker swarm init \
      --advertise-addr "$manager_ip" > /dev/null
  fi
}

lookup_and_set_tokens() {
  manager_token=$(docker-machine ssh ms-manager0 docker swarm join-token -q manager)
  worker_token=$(docker-machine ssh ms-manager0 docker swarm join-token -q worker)
}

lookup_and_set_manager_ip() {
  manager_ip=$(docker-machine ip ms-manager0)
}

deploy_swarm_visualizer() {
  lookup_and_set_manager_ip
  (
  eval "$(docker-machine env ms-manager0)"
  if [[ $(docker ps -qa -f 'Status=running' -f Name='swarm_visualizer') ]]; then
    return 0
  fi
  if [[ $(docker ps -qa -f 'Status=exited' -f Name='swarm_visualizer') ]]; then
    docker rm -vf swarm_visualizer > /dev/null
  fi
  docker run -it -d --name swarm_visualizer -p 5000:5000 -e HOST="$manager_ip" -e PORT=5000 -v /var/run/docker.sock:/var/run/docker.sock manomarks/visualizer
  )
}

cmd_start() {
  info "Starting miniswarm"
  cmd_scale "$@"
  echo -e "\n\n"
  info "Stack starup complete. To connect to your stack, run the following command:"
  info 'eval $(docker-machine env ms-manager0)'
}

cmd_vis() {
  deploy_swarm_visualizer
  url="http://${manager_ip}:5000"
  if [[ ${1:-""} == "--url" ]]; then
    echo "$url"
  else
    # FIXME: add sleep
    wait_for_command "curl -s $url -o /dev/null"
    info "Launching browser with URL: $url"
    xdg-open "$url"
  fi
}

cmd_scale() {
  info "Scaling miniswarm"
  case "$#" in
    0)
      # lookup what's already there
      num_managers=$(docker-machine ls -q | grep -c "ms-manager[0-9][0-9]*" || true)
      num_workers=$(docker-machine ls -q | grep -c "ms-worker[0-9][0-9]*" || true)
      if ((num_managers==0)) && ((num_workers==0)); then
        num_managers=1
        num_workers=0
      fi
    ;;
    1)
    num_managers=1
    num_workers=$((num_workers + $1 - num_managers))
      ;;
    2)
    num_managers=$1
    num_workers=$2
      ;;
    *)
      # FIXME: implement
      exit 1
  esac
  scale_cluster
}

cmd_stop() {
  info "Stopping miniswarm"
  stop_instances
}

cmd_delete() {
  info "Deleting miniswarm"
  num_managers=0
  num_workers=0
  set_wanted_instances
  info "Deleting: $extra_managers $extra_workers"
  delete_instances --force
}

cmd_service() {
  lookup_and_set_manager_ip
  port=$(docker service inspect --format '{{(index .Endpoint.Ports 0).PublishedPort}}' "$1")
  url="http://${manager_ip}:${port}"
  if [[ ${2:-""} == "--url" ]]; then
    echo "$url"
  else
    wait_for_command "curl -s $url -o /dev/null"
    info "Launching browser with URL: $url"
    xdg-open "$url"
  fi
}


main() {
  case "$1" in
    start)
      cmd_start "${@:2}"
      ;;
    stop)
      cmd_stop
      ;;
    scale)
      cmd_scale "${@:2}"
      ;;
    delete)
      cmd_delete
      ;;
    vis|visualize|visualizer)
      cmd_vis "${@:2}"
      ;;
    service)
      cmd_service "${@:2}"
      ;;
    *)
      err "Unknown command: $1"
      exit 1
      ;;
  esac
}

main "$@"
